# ReentrantLock及基于AQS的同步器sync

## ReentrantLock

重入锁,就是可以重复被线程调用的锁.

### 成员变量

```java
    /** Synchronizer providing all implementation mechanics */
    //所有同步的机制都是由这个对象提供
    private final Sync sync;
```

### 内部类 

ReentrantLock的内部类主要分为3种,此锁的基础同步控制。和下面细分的公平和非公平版本。使用AQS状态来表示锁的保留数。

#### Sync

##### 父类

* AbstractQueuedSynchronizer

也就是通常所说的AQS(抽象队列同步器),此类通过同步状态`state`属性,获取和释放参数,以及内部FIFO等待队列的同步器.部分针对同步器的使用范围，为同步提供了有效且可扩展的基础。如果这还不够，您可以使用`java.util.concurrent.atomic`类和您自己的自定义`java.util.Queue`类和`LockSupport`.其中具体的方法,可以看[https://juejin.im/post/5afb9ab3f265da0b736dd1e1](https://juejin.im/post/5afb9ab3f265da0b736dd1e1)

##### 主要方法

* nonfairTryAcquire

执行不公平的获取锁操作,TryAcquire方法会在子类,但是都需要非公平锁获取

```java
final boolean nonfairTryAcquire(int acquires) {
            //获取到当前线程
            final Thread current = Thread.currentThread();
            //获取同步状态
            int c = getState();
            //设置为独占模式
            if (c == 0) {                
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    
                    return true;
                }
            }
            // 设置为共享模式
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);                
                return true;
            }
            return false;
        }
```

