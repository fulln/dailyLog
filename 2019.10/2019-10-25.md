# 当日总节

> Date 11.53 pm

## TODAY  list

## Yesterday not finished

## Point

### ThreadPoolExecutor分析

线程池主要是解决了2个不同的问题:

1. 执行大量异步任务时的性能优化,提供资源绑定和管理的一种方式
2. 提供基础信息,如线程完成数量

为了易用性,提供了以下几种最为常见的线程池来使用

* newCachedThreadPool
    无界线程池,线程自带回收
* newFixedThreadPool
    固定大小的线程池
* newSingleThreadExecutor
    单例线程池

当一个新的任务通过execute提交到当前线程池下时,当前正运行的线程少于corePoolSize的时候,会去新建一个线程去执行这个任务.即使其他的线程是处理空闲状态.如果是多于corePoolSize 但是少于 maximumPoolSize的时候,这个时候等待队列满的时候才会去创建新的线程,通过设置corePoolSize and maximumPoolSize 这2个参数可以创建一个固定大小的线程池.也可以通过设置线程池中的最大线程数为一个极大的数(如2^32  - 1)来让他成为实际上一个无界的线程池.

队列中有3种不同的策略

* 直接切换 这种策略选择的是SynchronousQueue这个队列.这种队列将任务交给线程而不进入等待,如果没有立即可用的线程来执行任务的话,会直接任务运行失败,然后会创建一个新的线程.这个策略当处理一堆有内联关系的请求时避免了死锁,直接切换一般会设置成无界队列来避免执行新的任务的时候直接被拒绝掉.不过线程增长速度过快也可能导致处理不过来.

* 无界队列 这种策略选择的是LinkedBlockingQueue这个队列,这种会导致超出corePoolSize的队列的全部在等待队列中等待.因此只会创建核心线程,maximumPoolSize  这个参数在这个策略中也变得没啥用,这个也会有上面那个策略的问题

* 有界队列 一般会选择ArrayBlockingQueue ,有助于防止资源耗尽,但是调整起来比较麻烦,要是使用大队列和小池的话可以减少cpu消耗,但是会导致处理的效率变得很低下,如果任务经常阻塞,系统可能要更多的时间来处理.  要是使用小队列和大池的话,会提高cpu的消耗,但是也因此导致开销过大,也会影响到吞吐量.
